# Copyright 2020 Mickael Chen, Edouard Delasalles, Jean-Yves Franceschi, Patrick Gallinari, Sylvain Lamprier

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import math
import torch

import numpy as np
import tensorflow as tf

from metrics.fvd.fvd import calculate_fvd, create_id3_embedding, preprocess


def compute_embedding(x):
    """
    Computes FVD embeddings of the input video.
    """
    with tf.Graph().as_default():
        emb = create_id3_embedding(preprocess(tf.convert_to_tensor(x), (224, 224)))
        with tf.Session() as sess:
            sess.run(tf.global_variables_initializer())
            return sess.run(emb)


def fvd(real, fake):
    """
    Computes the FVD score of pair of input real samples (true data) and fake samples (generated by a model).

    Parameters
    ----------
    real : torch.*.Tensor
        CPU tensor representing samples from the real distribution of shape (length, batch, channels, width, height)
        with values in [0, 1].
    fake : torch.*.Tensor
        CPU tensor representing samples from the fake distribution of shape (length, batch, channels, width, height)
        with values in [0, 1].
    """
    tf.enable_eager_execution()
    # Custom preprocess
    n_ex = real.shape[1]
    assert n_ex >= 16
    if real.shape[2] == 1:
        real = real.repeat(1, 1, 3, 1, 1)
        fake = fake.repeat(1, 1, 3, 1, 1)
    real = real.permute(1, 0, 3, 4, 2).contiguous() * 255
    fake = fake.permute(1, 0, 3, 4, 2).contiguous() * 255
    # Split data in chunks of size 16 and compute embeddings
    embedding_real = []
    embedding_fake = []
    for k in range(int(math.ceil(n_ex / 16))):
        # Select a chunk of size 16
        start = k * 16
        stop = min(n_ex, (k + 1) * 16)
        n_k = stop - start
        real_k = real[start:stop]
        fake_k = fake[start:stop]
        if n_k < 16:
            # If we are in the last chunk, we fill the chunk with start data
            real_k = torch.cat([real_k, real[:16 - n_k]], 0)
            fake_k = torch.cat([fake_k, fake[:16 - n_k]], 0)
        # compute embeddings
        emb_real_k = compute_embedding(real_k)
        emb_fake_k = compute_embedding(fake_k)
        if n_k < 16:
            # retriev only true data
            emb_real_k = emb_real_k[:n_k]
            emb_fake_k = emb_fake_k[:n_k]
        embedding_real.append(emb_real_k)
        embedding_fake.append(emb_fake_k)
    embedding_real = np.concatenate(embedding_real, 0)
    embedding_fake = np.concatenate(embedding_fake, 0)
    # Compute FVD
    with tf.Graph().as_default():
        embedding_real = tf.convert_to_tensor(embedding_real)
        embedding_fake = tf.convert_to_tensor(embedding_fake)
        result = calculate_fvd(embedding_real, embedding_fake)
        with tf.Session() as sess:
            sess.run(tf.global_variables_initializer())
            return sess.run(result)
